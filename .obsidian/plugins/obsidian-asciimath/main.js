/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AsciiMathPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// node_modules/.pnpm/asciimath-parser@0.5.0/node_modules/asciimath-parser/dist/index.js
var h = /* @__PURE__ */ new Map([["alpha", { type: "Const", tex: "\\alpha" }], ["beta", { type: "Const", tex: "\\beta" }], ["gamma", { type: "Const", tex: "\\gamma" }], ["Gamma", { type: "Const", tex: "\\Gamma" }], ["delta", { type: "Const", tex: "\\delta" }], ["Delta", { type: "Const", tex: "\\Delta" }], ["epsi", { type: "Const", tex: "\\varepsilon" }], ["epsilon", { type: "Const", tex: "\\epsilon" }], ["varepsilon", { type: "Const", tex: "\\varepsilon" }], ["zeta", { type: "Const", tex: "\\zeta" }], ["eta", { type: "Const", tex: "\\eta" }], ["theta", { type: "Const", tex: "\\theta" }], ["Theta", { type: "Const", tex: "\\Theta" }], ["vartheta", { type: "Const", tex: "\\vartheta" }], ["iota", { type: "Const", tex: "\\iota" }], ["kappa", { type: "Const", tex: "\\kappa" }], ["lambda", { type: "Const", tex: "\\lambda" }], ["Lambda", { type: "Const", tex: "\\Lambda" }], ["mu", { type: "Const", tex: "\\mu" }], ["nu", { type: "Const", tex: "\\nu" }], ["xi", { type: "Const", tex: "\\xi" }], ["Xi", { type: "Const", tex: "\\Xi" }], ["pi", { type: "Const", tex: "\\pi" }], ["Pi", { type: "Const", tex: "\\Pi" }], ["rho", { type: "Const", tex: "\\rho" }], ["sigma", { type: "Const", tex: "\\sigma" }], ["Sigma", { type: "Const", tex: "\\Sigma" }], ["tau", { type: "Const", tex: "\\tau" }], ["upsilon", { type: "Const", tex: "\\upsilon" }], ["phi", { type: "Const", tex: "\\phi" }], ["varphi", { type: "Const", tex: "\\varphi" }], ["Phi", { type: "Const", tex: "\\Phi" }], ["chi", { type: "Const", tex: "\\chi" }], ["psi", { type: "Const", tex: "\\psi" }], ["Psi", { type: "Const", tex: "\\Psi" }], ["omega", { type: "Const", tex: "\\omega" }], ["Omega", { type: "Const", tex: "\\Omega" }], ["***", { type: "Const", tex: "\\star" }], ["star", { type: "Const", tex: "\\star" }], ["**", { type: "Const", tex: "\\ast" }], ["ast", { type: "Const", tex: "\\ast" }], ["*", { type: "Const", tex: "\\cdot" }], ["cdot", { type: "Const", tex: "\\cdot" }], ["//", { type: "Const", tex: "{/}" }], ["\\\\", { type: "Const", tex: "\\backslash" }], ["setminus", { type: "Const", tex: "\\setminus" }], ["xx", { type: "Const", tex: "\\times" }], ["|><", { type: "Const", tex: "\\ltimes" }], ["><|", { type: "Const", tex: "\\rtimes" }], ["|><|", { type: "Const", tex: "\\bowtie" }], ["-:", { type: "Const", tex: "\\div" }], ["@", { type: "Const", tex: "\\circ" }], ["o+", { type: "Const", tex: "\\oplus" }], ["ox", { type: "Const", tex: "\\otimes" }], ["o.", { type: "Const", tex: "\\odot" }], ["sum", { type: "Const", tex: "\\sum" }], ["prod", { type: "Const", tex: "\\prod" }], ["^^", { type: "Const", tex: "\\wedge" }], ["^^^", { type: "Const", tex: "\\bigwedge" }], ["vv", { type: "Const", tex: "\\vee" }], ["vvv", { type: "Const", tex: "\\bigvee" }], ["nn", { type: "Const", tex: "\\cap" }], ["nnn", { type: "Const", tex: "\\bigcap" }], ["uu", { type: "Const", tex: "\\cup" }], ["uuu", { type: "Const", tex: "\\bigcup" }], ["!=", { type: "Const", tex: "\\ne" }], ["lt", { type: "Const", tex: "<" }], ["<=", { type: "Const", tex: "\\leqslant" }], ["le", { type: "Const", tex: "\\le" }], ["gt", { type: "Const", tex: ">" }], [">=", { type: "Const", tex: "\\geqslant" }], ["ge", { type: "Const", tex: "\\ge" }], ["-<", { type: "Const", tex: "\\prec" }], [">-", { type: "Const", tex: "\\succ" }], ["-<=", { type: "Const", tex: "\\preceq" }], [">-=", { type: "Const", tex: "\\succeq" }], ["in", { type: "Const", tex: "\\in" }], ["!in", { type: "Const", tex: "\\notin" }], ["sub", { type: "Const", tex: "\\subset" }], ["sup", { type: "Const", tex: "\\supset" }], ["sube", { type: "Const", tex: "\\subseteq" }], ["supe", { type: "Const", tex: "\\supseteq" }], ["-=", { type: "Const", tex: "\\equiv" }], ["~=", { type: "Const", tex: "\\cong" }], ["~", { type: "Const", tex: "\\sim" }], ["~~", { type: "Const", tex: "\\approx" }], ["\\#", { type: "Const", tex: "\\#" }], ["\\&", { type: "Const", tex: "\\&" }], ["\\@", { type: "Const", tex: "@" }], ["\\%", { type: "Const", tex: "\\%" }], ["%", { type: "Const", tex: "\\%" }], ["\\_", { type: "Const", tex: "\\_" }], ["\\^", { type: "Const", tex: "\\^" }], ["\\$", { type: "Const", tex: "\\$" }], ["\\ ", { type: "Const", tex: "\\ " }], ["\\,", { type: "Const", tex: "\\," }], ["\\;", { type: "Const", tex: "\\;" }], ["\\:", { type: "Const", tex: "\\:" }], ["\\!", { type: "Const", tex: "\\!" }], ["enspace", { type: "Const", tex: "\\enspace" }], ["hspace", { type: "OperatorA", tex: "\\hspace{$1}" }], ["prop", { type: "Const", tex: "\\propto" }], ["complement", { type: "Const", tex: "\\complement" }], ["if", { type: "Text", tex: "if\\quad" }], ["otherwise", { type: "Text", tex: "otherwise\\quad" }], ["and", { type: "Text", tex: " and " }], ["or", { type: "Text", tex: " or " }], ["not", { type: "Const", tex: "\\neg" }], ["=>", { type: "Const", tex: "\\implies" }], ["<=>", { type: "Const", tex: "\\iff" }], ["iff", { type: "Const", tex: "\\iff" }], ["AA", { type: "Const", tex: "\\forall" }], ["EE", { type: "Const", tex: "\\exists" }], ["_|_", { type: "Const", tex: "\\bot" }], ["TT", { type: "Const", tex: "\\top" }], ["|--", { type: "Const", tex: "\\vdash" }], ["|==", { type: "Const", tex: "\\models" }], ["int", { type: "Const", tex: "\\int" }], ["oint", { type: "Const", tex: "\\oint" }], ["del", { type: "Const", tex: "\\partial" }], ["grad", { type: "Const", tex: "\\nabla" }], ["+-", { type: "Const", tex: "\\pm" }], ["O/", { type: "Const", tex: "\\varnothing" }], ["oo", { type: "Const", tex: "\\infty" }], ["aleph", { type: "Const", tex: "\\aleph" }], ["...", { type: "Const", tex: "\\ldots" }], [":.", { type: "Const", tex: "\\therefore" }], [":'", { type: "Const", tex: "\\because" }], ["/_", { type: "Const", tex: "\\angle" }], ["/_\\", { type: "Const", tex: "\\triangle" }], ["quad", { type: "Const", tex: "\\quad" }], ["qquad", { type: "Const", tex: "\\qquad" }], ["cdots", { type: "Const", tex: "\\cdots" }], ["vdots", { type: "Const", tex: "\\vdots" }], ["ddots", { type: "Const", tex: "\\ddots" }], ["diamond", { type: "Const", tex: "\\diamond" }], ["Lap", { type: "Const", tex: "\\mathscr{L}" }], ["square", { type: "Const", tex: "\\square" }], ["|__", { type: "LParen", tex: "\\lfloor" }], ["__|", { type: "RParen", tex: "\\rfloor" }], ["|~", { type: "LParen", tex: "\\lceil" }], ["~|", { type: "RParen", tex: "\\rceil" }], ["CC", { type: "Const", tex: "\\mathbb{C}" }], ["NN", { type: "Const", tex: "\\mathbb{N}" }], ["QQ", { type: "Const", tex: "\\mathbb{Q}" }], ["RR", { type: "Const", tex: "\\mathbb{R}" }], ["ZZ", { type: "Const", tex: "\\mathbb{Z}" }], ["'", { type: "Const", tex: "^{\\prime}" }], ["''", { type: "Const", tex: "^{\\prime\\prime}" }], ["'''", { type: "Const", tex: "^{\\prime\\prime\\prime}" }], ["lim", { type: "Const", tex: "\\lim" }], ["sin", { type: "Const", tex: "\\sin" }], ["cos", { type: "Const", tex: "\\cos" }], ["tan", { type: "Const", tex: "\\tan" }], ["sinh", { type: "Const", tex: "\\sinh" }], ["cosh", { type: "Const", tex: "\\cosh" }], ["tanh", { type: "Const", tex: "\\tanh" }], ["cot", { type: "Const", tex: "\\cot" }], ["sec", { type: "Const", tex: "\\sec" }], ["csc", { type: "Const", tex: "\\csc" }], ["arcsin", { type: "Const", tex: "\\arcsin" }], ["arccos", { type: "Const", tex: "\\arccos" }], ["arctan", { type: "Const", tex: "\\arctan" }], ["coth", { type: "Const", tex: "\\coth" }], ["sech", { type: "Const", tex: "\\sech" }], ["csch", { type: "Const", tex: "\\csch" }], ["exp", { type: "Const", tex: "\\exp" }], ["log", { type: "Const", tex: "\\log" }], ["ln", { type: "Const", tex: "\\ln" }], ["det", { type: "Const", tex: "\\det" }], ["dim", { type: "Const", tex: "\\dim" }], ["gcd", { type: "Const", tex: "\\gcd" }], ["lcm", { type: "Const", tex: "\\operatorname{lcm}" }], ["min", { type: "Const", tex: "\\min" }], ["max", { type: "Const", tex: "\\max" }], ["Sup", { type: "Const", tex: "\\sup" }], ["inf", { type: "Const", tex: "\\inf" }], ["mod", { type: "Const", tex: "\\operatorname{mod}" }], ["sgn", { type: "Const", tex: "\\operatorname{sgn}" }], ["abs", { type: "OperatorA", tex: "\\left|$1\\right|" }], ["norm", { type: "OperatorA", tex: "\\left\\|$1\\right\\|" }], ["floor", { type: "OperatorA", tex: "\\left\\lfloor$1\\right\\rfloor" }], ["ceil", { type: "OperatorA", tex: "\\left\\lceil$1\\right\\rceil" }], ["uarr", { type: "Const", tex: "\\uparrow" }], ["uparrow", { type: "Const", tex: "\\uparrow" }], ["darr", { type: "Const", tex: "\\downarrow" }], ["downarrow", { type: "Const", tex: "\\downarrow" }], ["rarr", { type: "Const", tex: "\\rightarrow" }], ["rightarrow", { type: "Const", tex: "\\rightarrow" }], ["to", { type: "Const", tex: "\\to" }], ["->", { type: "Const", tex: "\\to" }], [">->", { type: "Const", tex: "\\rightarrowtail" }], ["->>", { type: "Const", tex: "\\twoheadrightarrow" }], [">->>", { type: "Const", tex: "\u2916" }], ["|->", { type: "Const", tex: "\\mapsto" }], ["larr", { type: "Const", tex: "\\leftarrow" }], ["leftarrow", { type: "Const", tex: "\\leftarrow" }], ["harr", { type: "Const", tex: "\\leftrightarrow" }], ["rArr", { type: "Const", tex: "\\Rightarrow" }], ["lArr", { type: "Const", tex: "\\Leftarrow" }], ["hArr", { type: "Const", tex: "\\Leftrightarrow" }], ["curvArrLt", { type: "Const", tex: "\\curvearrowleft" }], ["curvArrRt", { type: "Const", tex: "\\curvearrowright" }], ["circArrLt", { type: "Const", tex: "\\circlearrowleft" }], ["circArrRt", { type: "Const", tex: "\\circlearrowright" }], ["sqrt", { type: "OperatorA", tex: "\\sqrt{ $1 }" }], ["root", { type: "OperatorOAB", tex: "\\sqrt[ $1 ]{ $2 }" }], ["frac", { type: "OperatorOAB", tex: "\\frac{ $1 }{ $2 }" }], ["/", { type: "OperatorAOB", tex: "\\frac{ $1 }{ $2 }" }], ["_", { type: "OperatorSup", tex: "_{ $1 }" }], ["^", { type: "OperatorSup", tex: "^{ $1 }" }], ["stackrel", { type: "OperatorOAB", tex: "\\stackrel{ $1 }{ $2 }" }], ["overset", { type: "OperatorOAB", tex: "\\overset{ $1 }{ $2 }" }], ["underset", { type: "OperatorOAB", tex: "\\underset{ $1 }{ $2 }" }], ["hat", { type: "OperatorA", tex: "\\hat{ $1 }" }], ["\\`", { type: "OperatorA", tex: "\\`{ $1 }" }], ["widehat", { type: "OperatorA", tex: "\\widehat{ $1 }" }], ["Hat", { type: "OperatorA", tex: "\\widehat{ $1 }" }], ["widetilde", { type: "OperatorA", tex: "\\widetilde{ $1 }" }], ["ol", { type: "OperatorA", tex: "\\overline{ $1 }" }], ["overline", { type: "OperatorA", tex: "\\overline{ $1 }" }], ["arc", { type: "OperatorA", tex: "\\stackrel{\\frown}{ $1 }" }], ["bar", { type: "OperatorA", tex: "\\bar{ $1 }" }], ["vec", { type: "OperatorA", tex: "\\vec{ $1 }" }], ["Vec", { type: "OperatorA", tex: "\\overrightarrow{ $1 }" }], ["tilde", { type: "OperatorA", tex: "\\tilde{ $1 }" }], ["Tilde", { type: "OperatorA", tex: "\\widetilde{ $1 }" }], ["dot", { type: "OperatorA", tex: "\\dot{ $1 }" }], ["ddot", { type: "OperatorA", tex: "\\ddot{ $1 }" }], ["ul", { type: "OperatorA", tex: "\\underline{ $1 }" }], ["underline", { type: "OperatorA", tex: "\\underline{ $1 }" }], ["underbrace", { type: "OperatorA", tex: "\\underbrace{ $1 }" }], ["ubrace", { type: "OperatorA", tex: "\\underbrace{ $1 }" }], ["overbrace", { type: "OperatorA", tex: "\\overbrace{ $1 }" }], ["obrace", { type: "OperatorA", tex: "\\overbrace{ $1 }" }], ["color", { type: "OperatorOAB", tex: "{ \\color{$1} $2 }" }], ["phantom", { type: "OperatorA", tex: "\\phantom{$1}" }], ["text", { type: "OperatorA", tex: "\\text{$1}" }], ["tex", { type: "Const", tex: "" }], ["mbox", { type: "OperatorA", tex: "\\mbox{$1}" }], ["op", { type: "OperatorA", tex: "\\operatorname{ $1 }" }], ["cancel", { type: "OperatorA", tex: "\\cancel{ $1 }" }], ["bb", { type: "OperatorA", tex: "\\mathbf{ $1 }" }], ["mathbf", { type: "OperatorA", tex: "\\mathbf{ $1 }" }], ["sf", { type: "OperatorA", tex: "\\mathsf{ $1 }" }], ["mathsf", { type: "OperatorA", tex: "\\mathsf{ $1 }" }], ["bbb", { type: "OperatorA", tex: "\\mathbb{ $1 }" }], ["mathbb", { type: "OperatorA", tex: "\\mathbb{ $1 }" }], ["cc", { type: "OperatorA", tex: "\\mathcal{ $1 }" }], ["mathcal", { type: "OperatorA", tex: "\\mathcal{ $1 }" }], ["tt", { type: "OperatorA", tex: "\\mathtt{ $1 }" }], ["mathtt", { type: "OperatorA", tex: "\\mathtt{ $1 }" }], ["fr", { type: "OperatorA", tex: "\\mathfrak{ $1 }" }], ["bm", { type: "OperatorA", tex: "\\boldsymbol{ $1 }" }], ["rm", { type: "OperatorA", tex: "\\mathrm{ $1 }" }], ["scr", { type: "OperatorA", tex: "\\mathscr{ $1 }" }], ["iint", { type: "Const", tex: "\\iint" }], ["iiint", { type: "Const", tex: "\\iiint" }], ["oiint", { type: "Const", tex: "\u222F" }], ["oiiint", { type: "Const", tex: "\u2230" }], ["laplace", { type: "Const", tex: "\\Delta" }], ["==", { type: "OperatorOptionalTwoParams", tex: "\\xlongequal[ $2 ]{ $1 }" }], ["-->", { type: "OperatorOptionalTwoParams", tex: "\\xrightarrow[ $2 ]{ $1 }" }], ["||", { type: "Const", tex: "\\Vert" }], ["!||", { type: "Const", tex: "\u2226" }], ["S=", { type: "Const", tex: "\u224C" }], ["S~", { type: "Const", tex: "\u223D" }], ["!-=", { type: "Const", tex: "\\not\\equiv" }], ["!|", { type: "Const", tex: "\u2224" }], ["!", { type: "OperatorAO", tex: "{$1 !}" }], ["!!", { type: "OperatorAO", tex: "{$1 !!}" }], ["!sube", { type: "Const", tex: "\\not\\sube" }], ["!supe", { type: "Const", tex: "\\not\\supe" }], ["subne", { type: "Const", tex: "\u228A" }], ["supne", { type: "Const", tex: "\u228B" }], ["lhd", { type: "Const", tex: "\\lhd" }], ["rhd", { type: "Const", tex: "\\rhd" }], ["normal", { type: "Const", tex: "\\unlhd" }], ["rnormal", { type: "Const", tex: "\\unrhd" }], ["hline", { type: "Const", tex: "\\hline" }], ["(", { type: "LParen", tex: "(" }], [")", { type: "RParen", tex: ")" }], ["[", { type: "LParen", tex: "[" }], ["]", { type: "RParen", tex: "]" }], ["{", { type: "LParen", tex: "\\lbrace" }], ["}", { type: "RParen", tex: "\\rbrace" }], ["(:", { type: "LParen", tex: "\\langle" }], [":)", { type: "RParen", tex: "\\rangle" }], ["{:", { type: "LParen", tex: "." }], [":}", { type: "RParen", tex: "." }], ["|", { type: "Paren", tex: "|" }], ["&", { type: "Align", tex: "&" }], ["&&", { type: "Align", tex: "&&" }], [",", { type: "Split", tex: "," }], [";", { type: "Split", tex: ";" }], ["-", { type: "OperatorMinus", tex: "{-$1 }" }], ["+", { type: "OperatorMinus", tex: "{+$1 }" }], ["part", { type: "OperatorPartial", tex: "\\partial" }], ["pp", { type: "OperatorPartial", tex: "\\partial" }], ["dd", { type: "OperatorPartial", tex: "\\mathrm{d}" }]]);
function _() {
  return { type: "Root", body: [] };
}
function y(n) {
  if (typeof n > "u")
    return { type: "Const", value: "", tex: "" };
  if (typeof n == "string")
    return { type: "Const", value: n, tex: n };
  let e;
  return n.type === "Text" ? e = n.tex.replace(/^(\\quad)?([^\\]+)(\\quad)?$/, (t, o, s, p) => `${o || ""}\\text{${s}}${p || ""}`) : e = n.tex, { type: "Const", value: n.value, tex: e };
}
function l(n) {
  let e = [];
  return n && (Array.isArray(n) ? e = n : e.push(n)), { type: "Flat", body: e };
}
function O() {
  return { type: "Matrix", params: [], lparen: ".", rparen: ".", alignment: "Center", dividerIndices: [] };
}
function C() {
  return { type: "ParamOne", tex: "", params: l() };
}
function f() {
  return { type: "ParamTwo", tex: "", params: [l(), l()] };
}
function N(n, e) {
  return { type: "Const", value: n.value, tex: `\\${e ? "left" : "right"}${n.tex}` };
}
function F(n, e) {
  let { closingIndex: t, semiIndex: o } = M(e, n);
  return t === -1 ? V(n, e) : o === -1 || o > t ? L(n, e, t) : z(n, e, t);
}
function z(n, e, t) {
  let o = n[e], s = O(), p = /* @__PURE__ */ new Set();
  s.lparen = `\\left${o.tex}`, o = n[++e];
  let a = [], r = null;
  for (; e < t; ) {
    if (o.type === "Split") {
      o.value === "," ? r ? (a.push(r), r = null) : a.push(y()) : o.value === ";" && (r && (a.push(r), r = null), s.params.push(a), a = []), o = n[++e];
      continue;
    } else if (o.type === "Paren") {
      r && (a.push(r), r = null), p.add(a.length), o = n[++e];
      continue;
    }
    for (r = l(), o = n[e]; e < t && o.type !== "Split" && o.type !== "Paren"; ) {
      let i = T(n, e);
      e = i.current, r.body.push(i.node), o = n[e];
    }
  }
  return r && (a.push(r), r = null), a.length > 0 && (s.params.push(a), a = []), s.dividerIndices = Array.from(p).sort((i, u) => i - u), o = n[e], e < n.length ? (e++, s.rparen = `\\right${o.tex}`, o.value === ":}" && (s.alignment = "Left")) : s.rparen = "\\right.", { node: s, current: e };
}
var m = class extends Error {
};
function L(n, e, t) {
  let o = n[e], s = l();
  if (s.body.push(N(o, true)), e = g(e + 1, t, n, s), e >= n.length)
    throw new m(`Read index out of range, index: ${e}`);
  return o = n[e], e++, s.body.push(N(o, false)), s.body[0].value === "{:" && s.body[s.body.length - 1].value === ":}" && (s.body[0].tex = "{", s.body[s.body.length - 1].tex = "}"), { node: s, current: e };
}
function V(n, e) {
  let t = n[e], o = l();
  return o.body.push({ type: "Const", value: t.value, tex: `\\left${t.tex}` }), e = g(e + 1, n.length, n, o), o.body.push({ type: "Const", value: t.value, tex: "\\right." }), { node: o, current: e };
}
function M(n, e) {
  let t = -1, o = -1, s = [];
  for (let p = n + 1; p < e.length; p++) {
    if (e[p].type === "LParen") {
      s.push("");
      continue;
    }
    if (s.length === 0) {
      if (e[p].value === ";" ? t === -1 && (t = p) : e[p].type === "RParen" && o === -1 && (o = p), t !== -1 && o !== -1)
        break;
    } else
      e[p].type === "RParen" && s.pop();
  }
  return { closingIndex: o, semiIndex: t };
}
function B(n, e, t) {
  let o = -1, s = -1, p = [];
  for (let a = e; a < t; a++) {
    if (n[a].type === "LParen") {
      p.push("");
      continue;
    }
    if (p.length > 0 && n[a].type === "RParen") {
      p.pop();
      continue;
    }
    if (!(p.length > 0) && (n[a].type === "RParen" || (n[a].value === ";" ? o === -1 && (o = a) : n[a].value === "|" && s === -1 && (s = a), o !== -1 && s !== -1)))
      break;
  }
  return { semiIndex: o, barIndex: s };
}
function E(n, e) {
  let t = n[e], { semiIndex: o, barIndex: s } = B(n, e + 1, n.length);
  if (s === -1)
    return q(e);
  if (o === -1 || o > s) {
    let i = l();
    return e++, i.body.push(y("\\left|")), e = g(e, s, n, i), i.body.push(y("\\right|")), e = s + 1, { current: e, node: i };
  }
  let p = O();
  p.lparen = "\\left|", p.rparen = "\\right|", t = n[++e];
  let a = [], r = null;
  for (; e < s; ) {
    if (t.type === "Split") {
      switch (t.value) {
        case ",": {
          r && (a.push(r), r = null);
          break;
        }
        case ";": {
          r && (a.push(r), r = null), p.params.push(a), a = [];
          break;
        }
      }
      t = n[++e];
      continue;
    }
    for (r = l(), t = n[e]; e < s && t.type !== "Split"; ) {
      let i = T(n, e);
      e = i.current, r.body.push(i.node), t = n[e];
    }
  }
  return r && (a.push(r), r = null), a.length > 0 && (p.params.push(a), a = []), e = s + 1, { node: p, current: e };
}
function g(n, e, t, o) {
  for (; n < e; ) {
    let s = T(t, n);
    n = s.current, o.body.push(s.node);
  }
  return n;
}
function q(n) {
  return { current: n + 1, node: { type: "Const", value: "|", tex: "\\mid" } };
}
function x(n) {
  let e = n.body[0], t = n.body[n.body.length - 1];
  return e.type === "Const" && t.type === "Const" && e.value === "(" && t.value === ")" && (n.body.pop(), n.body.shift()), n;
}
function I(n, e, t) {
  let o = n[e], s = y(), p = "", a = "", r = "";
  if (o.value === "^" || o.value === "_") {
    p = o.value === "^" ? "_" : "^", a = o.value, e++;
    let d = T(n, e, false);
    d.node.type === "Flat" && (d.node = x(d.node)), s = d.node, e = d.current;
  }
  let i = y();
  if (e < n.length && (o = n[e], o.value === p)) {
    r = o.value, e++;
    let d = T(n, e, false);
    d.node.type === "Flat" && (d.node = x(d.node)), i = d.node, e = d.current;
  }
  let u = f();
  return u.tex = t.tex, u.params[0] = (() => a === "^" ? s : r === "^" ? i : y())(), u.params[1] = (() => a === "_" ? s : r === "_" ? i : y())(), { node: u, current: e };
}
function W(n, e, t, o) {
  let s;
  n.type === "Flat" ? s = n : (s = l(), s.body.push(n));
  let p = C();
  p.tex = e.tex;
  let a = T(t, o, false);
  return o = a.current, a.node.type === "Flat" && (a.node = x(a.node)), p.params = a.node, s.body.push(p), n = s, { node: n, current: o };
}
function D(n, e) {
  let t = C();
  return t.params = n, t.tex = e.tex, n = t, n;
}
function K(n, e, t, o) {
  let s = f();
  n.type === "Flat" && (n = x(n)), s.tex = e.tex, s.params[0] = n;
  let p = T(t, o);
  return o = p.current, p.node.type === "Flat" && (p.node = x(p.node)), s.params[1] = p.node, n = s, { node: n, current: o };
}
function v(n, e, t) {
  let o = C(), s = n[e];
  o.tex = s.tex, e++;
  let p = T(n, e, t);
  return e = p.current, p.node.type === "Flat" && (p.node = x(p.node)), o.params = p.node, { node: o, current: e };
}
function G(n, e) {
  let t = n[e];
  if (e > 0) {
    let a = n[e - 1];
    if (a.type !== "OperatorSup" && a.type !== "OperatorA" && a.type !== "OperatorOAB" && a.type !== "OperatorAOB")
      return { node: y(t.value), current: e + 1 };
  } else
    return { node: y(t.value), current: e + 1 };
  if (e++, e >= n.length)
    return { node: y(t.value), current: e };
  if (n[e].type === "RParen")
    return { node: y(t.value), current: e };
  let s = T(n, e, true);
  e = s.current, s.node.type === "Flat" && (s.node = x(s.node));
  let p = C();
  return p.tex = t.tex, p.params = s.node, { node: p, current: e };
}
function Q(n, e, t) {
  let o = l();
  return o.body.push(y(n)), e && o.body.push(e), o.body.push(t), o;
}
function j(n, e) {
  return l(n.body.map((t) => [y(e), t]).flat());
}
function U(n, e) {
  let t = f(), o = n[e];
  t.tex = "\\frac{ $1 }{ $2 }";
  let s = o.tex, p = null;
  if (e++, e >= n.length)
    return { node: t, current: e };
  if (o = n[e], o.type === "OperatorSup") {
    let i = v(n, e, false);
    e = i.current, p = i.node;
  }
  let a = T(n, e, true);
  if (e = a.current, a.node.type === "Flat" && (a.node = x(a.node)), t.params[0] = Q(s, p, a.node), e >= n.length)
    return { node: t, current: e };
  let r = T(n, e);
  return e = r.current, r.node.type === "Flat" ? (r.node = x(r.node), r.node = j(r.node, s)) : (r.node = l(r.node), r.node.body.unshift(y(s)), p && r.node.body.push(p)), t.params[1] = r.node, { node: t, current: e };
}
function T(n, e, t = true) {
  if (e >= n.length)
    return { node: y(), current: e };
  let o = n[e], s;
  switch (o.type) {
    case "Const":
    case "Text":
    case "NumberLiteral":
    case "StringLiteral": {
      e++, s = y(o);
      break;
    }
    case "LParen": {
      ({ node: s, current: e } = F(n, e));
      break;
    }
    case "Paren": {
      ({ node: s, current: e } = E(n, e));
      break;
    }
    case "OperatorSup":
    case "OperatorA": {
      ({ node: s, current: e } = v(n, e, false));
      break;
    }
    case "OperatorMinus": {
      ({ node: s, current: e } = G(n, e));
      break;
    }
    case "OperatorOAB": {
      s = f(), s.tex = o.tex, e++;
      let p = T(n, e);
      e = p.current, p.node.type === "Flat" && (p.node = x(p.node)), s.params[0] = p.node;
      let a = T(n, e);
      e = a.current, a.node.type === "Flat" && (a.node = x(a.node)), s.params[1] = a.node;
      break;
    }
    case "OperatorOptionalTwoParams": {
      if (e++, e >= n.length) {
        s = y(`${o.tex.replace(/[\{\[] \$\d+ [\}\]]/g, "")}{}`);
        break;
      }
      ({ node: s, current: e } = I(n, e, o));
      break;
    }
    case "OperatorPartial": {
      ({ node: s, current: e } = U(n, e));
      break;
    }
    case "Split":
    case "Align": {
      e++, s = y(o);
      break;
    }
    case "RParen": {
      e++, s = y(o);
      break;
    }
    default:
      throw new Error(`Unmatched token in walk ${o.value}`);
  }
  if (e < n.length && t) {
    let p = true;
    for (; p && e < n.length; ) {
      let a = n[e];
      switch (a.type) {
        case "OperatorAOB": {
          ({ node: s, current: e } = K(s, a, n, e + 1));
          break;
        }
        case "OperatorAO": {
          s = D(s, a), e++;
          break;
        }
        case "OperatorSup": {
          ({ node: s, current: e } = W(s, a, n, e + 1));
          break;
        }
        default:
          p = false;
      }
    }
  }
  return { node: s, current: e };
}
function A(n) {
  let e = _(), t = 0;
  for (; t < n.length; ) {
    let o = T(n, t);
    t = o.current, e.body.push(o.node);
  }
  return e;
}
function Z(n) {
  let e = n.dividerIndices, t = "\\begin{array}", o = "c";
  if (n.alignment === "Left" && (o = "l"), e.length) {
    let s = e[e.length - 1];
    for (let a = e.length - 1; a >= 1; a--)
      e[a] -= e[a - 1];
    t += "{";
    for (let a = 0; a < e.length; a++)
      t += `${"".padEnd(e[a], o)}|`;
    let p = Math.max(...n.params.map((a) => a.length));
    t += `${"".padEnd(p - s, o)}}`;
  } else {
    let s = Math.max(...n.params.map((p) => p.length));
    t += `{${"".padEnd(s, o)}}`;
  }
  return [t, "\\end{array}"];
}
function k(n) {
  switch (n.type) {
    case "Const":
      return n.tex;
    case "Root": {
      let e = n.body.map(k).join(" ");
      return n.body.find((t) => t.type === "Const" && (t.value === "&" || t.tex === "\\\\")) && (e = `\\begin{aligned}${e}\\end{aligned}`), e;
    }
    case "Flat":
      return n.body.map(k).join(" ");
    case "Matrix": {
      let [e, t] = Z(n);
      return [n.lparen, e, n.params.map((o) => o.map(k).join(" & ")).join("\\\\"), "\\\\", t, n.rparen].join(" ");
    }
    case "ParamOne":
      return n.tex.replace("$1", k(n.params));
    case "ParamTwo":
      return n.tex.replace("$1", k(n.params[0])).replace("$2", k(n.params[1]));
  }
}
var w = /[0-9]/;
var X = /\S/;
var Y = (n) => {
  let { value: e = "", current: t } = n;
  return { value: e, isKeyWord: false, current: t, tex: e, type: "Text" };
};
var P = (n) => {
  let { value: e = "", current: t } = n;
  return { value: e, isKeyWord: false, current: t, tex: e, type: "Const" };
};
var b = class {
  constructor(e) {
    __publicField(this, "_root");
    __publicField(this, "_char_to_index", /* @__PURE__ */ new Map());
    __publicField(this, "_n");
    if (e.length === 0)
      throw new Error("Cannot create Trie since the length of nodes is 0");
    e.forEach((o) => {
      if (o.length !== 1)
        throw new Error(`Value \`${o}\` is invalid, the length of char must be 1`);
    });
    let t = Array.from(new Set(e));
    this._n = t.length, this._root = new c(this._n), t.forEach((o, s) => {
      this._char_to_index.set(o, s);
    });
  }
  c2i(e) {
    return this._char_to_index.get(e);
  }
  insert(e) {
    if (e.length === 0)
      return;
    let t = this._root;
    [...e].forEach((o, s) => {
      let p = this.c2i(o);
      if (typeof p > "u")
        throw new Error(`key \`${o}\` not in key set`);
      t._nextNode[p] === null && (t._nextNode[p] = new c(this._n)), t = t._nextNode[p], s === e.length - 1 && (t._end = true);
    });
  }
  search(e) {
    if (!this._root._nextNode.find((s) => s !== null) || e.length === 0)
      return false;
    let t = this._root, o = 0;
    for (; o < e.length; o++) {
      let s = e[o], p = this.c2i(s);
      if (typeof p > "u")
        throw new Error(`key \`${s}\` not in key set`);
      if (t._nextNode[p] === null)
        return false;
      t = t._nextNode[p];
    }
    return o === e.length;
  }
  tryParsing(e, t = 0) {
    let o = "", s = this._root, p = false, a = t;
    for (; a < e.length; a++) {
      let i = e[a], u = this.c2i(i);
      if (typeof u > "u" || s._nextNode[u] === null)
        break;
      o += i, s = s._nextNode[u], p = s._end;
    }
    let r = (() => p ? h.get(o) : { tex: o, type: "StringLiteral" })();
    return { value: o, isKeyWord: p, current: a, ...r };
  }
  tryParsingNumber(e, t) {
    let o = e[t], s = "";
    for (; w.test(o) && t < e.length; )
      s += o, o = e[++t];
    for (o === "." && (s += o, o = e[++t]); w.test(o) && t < e.length; )
      s += o, o = e[++t];
    return { value: s, isKeyWord: false, current: t, tex: s, type: "NumberLiteral" };
  }
  tryParsingString(e, t) {
    let o = e[t], s = "";
    for (; X.test(o) && t < e.length; ) {
      let p = this.c2i(o);
      if (typeof p < "u" && this._root._nextNode[p] !== null)
        break;
      s += o, o = e[++t];
    }
    return { value: s, isKeyWord: false, current: t, tex: s, type: "StringLiteral" };
  }
  tryParsingNewLines(e, t) {
    let o = e[t], s = "";
    for (; /\n/.test(o) && t < e.length; )
      s += o, o = e[++t];
    return s.length >= 2 ? { value: s, isKeyWord: true, current: t, tex: "\\\\", type: "Align" } : { value: "", isKeyWord: false, current: t, tex: "", type: "None" };
  }
  getPlainTextInDoubleQuote(e, t) {
    let o = "", s = e[t];
    if (s === '"') {
      for (s = e[++t]; s !== '"' && t < e.length; )
        o += s, s = e[++t];
      if (s === '"')
        return t++, { current: t, value: o };
    }
    return { value: o, current: t };
  }
  tryParsingText(e, t) {
    let { value: o, current: s } = this.getPlainTextInDoubleQuote(e, t);
    return { value: o, isKeyWord: false, current: s, tex: o, type: "Text" };
  }
  getColorString(e, t) {
    let o = "";
    for (; t < e.length; ) {
      let s = e[t];
      if (!/[#\da-z]/i.test(s))
        break;
      o += s, t++;
    }
    return { value: o, isKeyWord: false, current: t, tex: o, type: "Const" };
  }
  skipSpaces(e, t) {
    for (; t < e.length; ) {
      let o = e[t];
      if (!/\s/.test(o))
        break;
      t++;
    }
    return t;
  }
  processColor(e, t) {
    let o = false, s = { value: "", isKeyWord: false, current: t, tex: "", type: "Const" };
    if (t = this.skipSpaces(e, t), t >= e.length)
      return s;
    {
      let p = e[t];
      /[\(\{\[]/.test(p) && (o = true, t++);
    }
    if (t = this.skipSpaces(e, t), s = this.getColorString(e, t), t = s.current, t = this.skipSpaces(e, t), s.current = t, t >= e.length)
      return s;
    {
      let p = e[t];
      /[\)\}\]]/.test(p) && o && t++;
    }
    return s.current = t, s;
  }
  getPlainText(e, t, o) {
    let s = false, p = e[t];
    for (; /\s/.test(p); )
      p = e[++t];
    s = p === "(";
    let a = "";
    if (s) {
      for (p = e[++t]; t < e.length && p !== ")"; )
        a += p, p = e[++t];
      return t++, o({ current: t, value: a });
    }
    for (; t < e.length && /\S/.test(p); )
      a += p, p = e[++t];
    return o({ current: t, value: a });
  }
  tryParsingAll(e) {
    let t = 0, o = [], s = 0, p = [...e];
    for (; t < p.length; ) {
      {
        let r = this.tryParsingNewLines(p, t);
        if (t = r.current, r.value !== "") {
          o.push(r);
          continue;
        }
      }
      if (/\s/.test(p[t])) {
        t++;
        continue;
      }
      let a = this.tryParsing(p, t);
      if (t = a.current, a.value !== "") {
        switch (a.value) {
          case "text": {
            a = this.getPlainText(p, t, Y), t = a.current, o.push(a);
            break;
          }
          case "tex": {
            t = this.skipSpaces(p, t);
            let { value: r, current: i } = this.getPlainTextInDoubleQuote(p, t);
            t = i, a = P({ current: t, value: r }), o.push(a);
            break;
          }
          case "hspace": {
            o.push(a);
            let r = this.getPlainText(p, t, P);
            t = r.current, o.push(r);
            break;
          }
          case "color": {
            o.push(a);
            let r = this.processColor(p, t);
            t = r.current, o.push(r);
            break;
          }
          default:
            o.push(a);
        }
        continue;
      }
      {
        let r = this.tryParsingNumber(p, t);
        if (t = r.current, r.value !== "") {
          o.push(r);
          continue;
        }
      }
      {
        let r = this.tryParsingText(p, t);
        if (t = r.current, r.value !== "") {
          o.push(r);
          continue;
        }
      }
      {
        let r = this.tryParsingString(p, t);
        if (t = r.current, r.value !== "") {
          o.push(r);
          continue;
        }
      }
      if (s++, s > p.length * 2)
        throw new Error("Oops! There may be an infinity loop");
    }
    return o;
  }
};
var c = class {
  constructor(e) {
    __publicField(this, "_nextNode", []);
    __publicField(this, "_end", false);
    this._nextNode = Array.from({ length: e }, () => null);
  }
};
function $(n = {}) {
  var _a;
  let e = /* @__PURE__ */ new Set([]);
  (_a = n.extConst) == null ? void 0 : _a.forEach(([s, p]) => {
    h.set(s, { type: "Const", tex: p });
  });
  for (let s of h.keys())
    [...s].forEach((p) => e.add(p));
  let t = Array.from(e);
  t.push(" ");
  let o = new b(t);
  for (let s of h.keys())
    o.insert(s);
  return o;
}
function H(n) {
  var _a, _b;
  let e = { display: true, extConst: [["dx", "{\\text{d}x}"], ["dy", "{\\text{d}y}"], ["dz", "{\\text{d}z}"], ["dt", "{\\text{d}t}"], ["#", "\\displaystyle"]], replaceBeforeTokenizing: [[/&#(x?[0-9a-fA-F]+);/g, (t, o) => String.fromCodePoint(o[0] === "x" ? `0${o}` : o)]] };
  return typeof (n == null ? void 0 : n.display) < "u" && (e.display = n == null ? void 0 : n.display), ((_a = n == null ? void 0 : n.extConst) == null ? void 0 : _a.length) && e.extConst.push(...n.extConst), ((_b = n == null ? void 0 : n.replaceBeforeTokenizing) == null ? void 0 : _b.length) && e.replaceBeforeTokenizing.push(...n.replaceBeforeTokenizing), e;
}
var R = class {
  constructor(e) {
    __publicField(this, "trie");
    __publicField(this, "display");
    __publicField(this, "replaceLaws");
    let { display: t, extConst: o, replaceBeforeTokenizing: s } = H(e);
    this.trie = $({ extConst: o }), this.display = t, this.replaceLaws = s;
  }
  toTex(e) {
    try {
      e = this.replaceLaws.reduce((o, s) => (typeof s[1] == "function", o.replaceAll(s[0], s[1])), e);
      let t = k(A(this.trie.tryParsingAll(e)));
      return this.display && (t = `\\displaystyle{ ${t} }`), t;
    } catch (t) {
      return `\\text{${String(t)}}`;
    }
  }
};

// src/utils.ts
function normalizeEscape(escape) {
  return escape.replace(/([$^\\.()[\]{}*?|])/g, "\\$1");
}

// src/inline.ts
var import_view = require("@codemirror/view");
var import_language = require("@codemirror/language");
var import_obsidian = require("obsidian");
var AM = new R();
function selectionAndRangeOverlap(selection, rangeFrom, rangeTo) {
  for (const range of selection.ranges) {
    if (range.from <= rangeTo && range.to >= rangeFrom)
      return true;
  }
  return false;
}
function inlineRender(view, plugin) {
  const currentFile = app.workspace.getActiveFile();
  if (!currentFile)
    return;
  const widgets = [];
  const selection = view.state.selection;
  const regex = /.*?_?inline-code_?.*/;
  for (const { from, to } of view.visibleRanges) {
    (0, import_language.syntaxTree)(view.state).iterate({
      from,
      to,
      enter: (node) => {
        const type = node.type;
        if (type.name.includes("formatting"))
          return;
        if (!regex.test(type.name))
          return;
        const start = node.from;
        const end = node.to;
        const { open, close } = plugin.settings.inline;
        if (selectionAndRangeOverlap(selection, start - open.length + 1, end + close.length - 1))
          return;
        const original = view.state.doc.sliceString(start - open.length + 1, end + close.length - 1).trim();
        const regex2 = new RegExp(`^${normalizeEscape(open)}(.*?)${normalizeEscape(close)}$`);
        const matches = original.match(regex2);
        if (!matches)
          return;
        widgets.push(import_view.Decoration.replace({
          widget: new InlineWidget(matches[1], view),
          inclusive: false,
          block: false
        }).range(start - 1, end + 1));
      }
    });
  }
  return import_view.Decoration.set(widgets, true);
}
var InlineWidget = class extends import_view.WidgetType {
  constructor(rawQuery, view) {
    super();
    this.rawQuery = rawQuery;
    this.view = view;
  }
  eq(other) {
    if (other.rawQuery === this.rawQuery)
      return true;
    return false;
  }
  toDOM(_view) {
    const tex = AM.toTex(this.rawQuery);
    const mathEl = (0, import_obsidian.renderMath)(tex, false);
    (0, import_obsidian.finishRenderMath)();
    return mathEl;
  }
};
function inlinePlugin(plugin) {
  return import_view.ViewPlugin.fromClass(class {
    constructor(view) {
      var _a;
      this.decorations = (_a = inlineRender(view, plugin)) != null ? _a : import_view.Decoration.none;
    }
    update(update) {
      var _a;
      if (!update.state.field(import_obsidian.editorLivePreviewField)) {
        this.decorations = import_view.Decoration.none;
        return;
      }
      if (update.docChanged || update.viewportChanged || update.selectionSet)
        this.decorations = (_a = inlineRender(update.view, plugin)) != null ? _a : import_view.Decoration.none;
    }
  }, { decorations: (v2) => v2.decorations });
}

// src/main.ts
var DEFAULT_SETTINGS = {
  blockPrefix: ["asciimath", "am"],
  inline: {
    open: "`$",
    close: "$`"
  },
  customSymbols: []
};
function toTex(am, content) {
  const tex = am.toTex(content);
  return tex.replace(/(\{|\})(\1+)/g, (...args) => Array(args[2].length + 1).fill(args[1]).join(" "));
}
var AsciiMathPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.existPrefixes = [];
    this.postProcessors = /* @__PURE__ */ new Map();
  }
  async onload() {
    await this.loadSettings();
    await (0, import_obsidian2.loadMathJax)();
    this.AM = new R({
      extConst: this.settings.customSymbols
    });
    if (!MathJax) {
      console.warn("MathJax was not defined despite loading it.");
      new import_obsidian2.Notice("Error: MathJax was not defined despite loading it!");
      return;
    }
    this.postProcessors = /* @__PURE__ */ new Map();
    this.app.workspace.onLayoutReady(async () => {
      this.settings.blockPrefix.forEach((prefix) => {
        this.registerAsciiMathBlock(prefix);
        this.existPrefixes.push(prefix);
      });
    });
    this.registerEditorExtension([inlinePlugin(this)]);
    this.registerMarkdownPostProcessor(this.postProcessorInline.bind(this));
    this.addCommand({
      id: "insert-asciimath-block",
      name: "Insert asciimath block",
      editorCallback: (editor, _view) => {
        editor.replaceSelection(`\`\`\`${this.settings.blockPrefix[0] || "asciimath"}
${editor.getDoc().getSelection()}
\`\`\``);
        const cursor = editor.getCursor();
        editor.setCursor(cursor.line - 1);
      }
    });
    this.addCommand({
      id: "convert-am-block-into-mathjax-in-current-file",
      name: "Convert asciimath block into mathjax in current file",
      editorCallback: (editor, _view) => {
        this.editorTransactionConvertFormula(editor);
      }
    });
    this.addSettingTab(new AsciiMathSettingTab(this.app, this));
    console.log("Obsidian asciimath loaded");
  }
  editorTransactionConvertFormula(editor) {
    const content = editor.getValue();
    const blockReg = new RegExp(`((\`|~){3,})(${this.settings.blockPrefix.join("|")})([\\s\\S]*?)\\n\\1`, "gm");
    const [open, close] = Object.values(this.settings.inline).map(normalizeEscape);
    const inlineReg = new RegExp(`${open}(.*?)${close}`, "g");
    const changes = [];
    try {
      const blockIterator = content.matchAll(blockReg);
      let match;
      while (!(match = blockIterator.next()).done) {
        const index = match.value.index;
        if (typeof index === "undefined")
          throw new Error("Invalid index: while converting block fomula");
        const amContent = match.value[4];
        if (typeof amContent !== "string")
          throw new Error(`Invalid asciimath formula, index: ${index}`);
        const from = editor.offsetToPos(index);
        const to = editor.offsetToPos(index + match.value[0].length);
        changes.push({
          text: `$$
${toTex(this.AM, amContent)}
$$`,
          from,
          to
        });
      }
      const inlineIterator = content.matchAll(inlineReg);
      while (!(match = inlineIterator.next()).done) {
        const index = match.value.index;
        if (typeof index === "undefined")
          throw new Error("Invalid index: while converting inline formula");
        const amContent = match.value[1];
        if (typeof amContent !== "string")
          throw new Error(`Invalid asciimath formula, index: ${index}`);
        const from = editor.offsetToPos(index);
        const to = editor.offsetToPos(index + match.value[0].length);
        changes.push({
          text: `$${toTex(this.AM, amContent)}$`,
          from,
          to
        });
      }
      if (changes.length === 0) {
        new import_obsidian2.Notice("No asciimath formulas converted!");
        return;
      }
      editor.transaction({ changes });
      new import_obsidian2.Notice(`Successfully converted ${changes.length} asciimath formulas!`);
    } catch (e) {
      new import_obsidian2.Notice(String(e));
    }
  }
  registerAsciiMathBlock(prefix) {
    this.postProcessors.set(prefix, this.registerMarkdownCodeBlockProcessor(prefix, (src, el, ctx) => this.postProcessor(prefix, src, el, ctx)));
  }
  async postProcessorInline(el, _ctx) {
    const nodeList = el.querySelectorAll("code");
    if (!nodeList.length)
      return;
    for (let i = 0; i < nodeList.length; i++) {
      const node = nodeList.item(i);
      if (node.className.trim())
        continue;
      let { open, close } = this.settings.inline;
      open = open.slice(1);
      close = close.substring(0, close.length - 1);
      const regex = new RegExp(`^${normalizeEscape(open)}(.*?)${normalizeEscape(close)}$`);
      const matches = node.innerText.match(regex);
      if (!matches)
        continue;
      const tex = this.AM.toTex(matches[1]);
      const mathEl = (0, import_obsidian2.renderMath)(tex, false);
      (0, import_obsidian2.finishRenderMath)();
      node.replaceWith(mathEl);
    }
  }
  postProcessor(_prefix, src, el, _2) {
    const tex = this.AM.toTex(src);
    const mathEl = (0, import_obsidian2.renderMath)(tex, true);
    el.appendChild(mathEl);
    (0, import_obsidian2.finishRenderMath)();
  }
  onunload() {
    console.log("Obsidian asciimath unloaded");
    this.unregister();
  }
  unregister() {
    this.postProcessors.forEach((value) => {
      import_obsidian2.MarkdownPreviewRenderer.unregisterPostProcessor(value);
    });
    this.postProcessors.clear();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
function validateSettings(settings) {
  if (settings.blockPrefix.length < 1) {
    return {
      isValid: false,
      message: "You should add at least 1 block prefix!"
    };
  }
  const { open, close } = settings.inline;
  if (!open.startsWith("`") || open.length <= 1 || open.startsWith("``")) {
    return {
      isValid: false,
      message: "Invalid inline leading escape!"
    };
  }
  if (!close.endsWith("`") || close.length <= 1 || close.endsWith("``")) {
    return {
      isValid: false,
      message: "Invalid inline trailing escape!"
    };
  }
  const { customSymbols } = settings;
  if (customSymbols.find((pair) => pair.length !== 2)) {
    return {
      isValid: false,
      message: "Custom rule should be two string split with a comma!"
    };
  }
  return {
    isValid: true,
    message: "OK"
  };
}
var AsciiMathSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for asciimath" });
    new import_obsidian2.Setting(containerEl).setName("Code block prefix aliases").setDesc("Seperate different aliases with comma.").addText((text) => text.setPlaceholder("asciimath, am").setValue(this.plugin.settings.blockPrefix.join(", ")).onChange((0, import_obsidian2.debounce)((value) => {
      this.plugin.settings.blockPrefix = value.split(",").map((s) => s.trim()).filter(Boolean);
    }, 1e3)));
    new import_obsidian2.Setting(containerEl).setName("Inline asciimath start").setDesc("The leading escape of the inline asciimath formula. It should starts with **only one backtick**.").addText((text) => text.setPlaceholder("`$").setValue(this.plugin.settings.inline.open).onChange((0, import_obsidian2.debounce)((value) => {
      this.plugin.settings.inline.open = value;
    }, 1e3)));
    new import_obsidian2.Setting(containerEl).setName("Inline asciimath end").setDesc("The trailing escape of the inline asciimath formula. It should ends with **only one backtick**.").addText((text) => text.setPlaceholder("$`").setValue(this.plugin.settings.inline.close).onChange((0, import_obsidian2.debounce)((value) => {
      this.plugin.settings.inline.close = value;
    }, 1e3)));
    new import_obsidian2.Setting(containerEl).setName("Custom symbols").setDesc("Transforms custom symbols into LaTeX symbols. One row for each rule.").addTextArea((text) => {
      const el = text.setPlaceholder("symbol1, \\LaTeXSymbol1\nsymbol2, \\LaTeXSymbol2\n...").setValue(this.plugin.settings.customSymbols.map((r) => r.join(", ")).join("\n")).onChange((0, import_obsidian2.debounce)((value) => {
        this.plugin.settings.customSymbols = value.split("\n").map((r) => r.split(",").map((s) => s.trim()).filter(Boolean)).filter((l2) => l2.length);
      }, 1e3));
      el.inputEl.addClass("__asciimath_settings_custom-symbols");
    });
    new import_obsidian2.Setting(containerEl).setName("Don't forget to save and reload settings \u2192").addButton((btn) => btn.setButtonText("Save").onClick(async () => {
      const valid = validateSettings(this.plugin.settings);
      if (!valid.isValid) {
        new import_obsidian2.Notice(valid.message);
        return;
      }
      await this.plugin.saveSettings();
      await this.plugin.loadSettings();
      this.plugin.settings.blockPrefix.forEach((prefix) => {
        if (!this.plugin.existPrefixes.includes(prefix))
          this.plugin.registerAsciiMathBlock(prefix);
      });
      this.plugin.AM = new R({
        extConst: this.plugin.settings.customSymbols
      });
      new import_obsidian2.Notice("Asciimath settings reloaded successfully!");
    }));
  }
};
