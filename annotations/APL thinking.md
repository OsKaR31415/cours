---
annotation-target: "APL thinking examples.pdf"
---
# APL thinking




>%%
>```annotation-json
>{"created":"2022-06-04T12:13:42.448Z","updated":"2022-06-04T12:13:42.448Z","document":{"title":"APL thinking examples.pdf","link":[{"href":"urn:x-pdf:36781331487d52f3605f75c4bdd9e2a8"},{"href":"vault:/APL thinking examples.pdf"}],"documentFingerprint":"36781331487d52f3605f75c4bdd9e2a8"},"uri":"vault:/APL thinking examples.pdf","target":[{"source":"vault:/APL thinking examples.pdf","selector":[{"type":"TextPositionSelector","start":1220,"end":1274},{"type":"TextQuoteSelector","exact":"we must ask how APL helps (or hinders) problem-solving","prefix":"ge for thinking about problems, ","suffix":". Specifically, just what is uni"}]}]}
>```
>%%
>*%%PREFIX%%ge for thinking about problems,%%HIGHLIGHT%% ==we must ask how APL helps (or hinders) problem-solving== %%POSTFIX%%. Specifically, just what is uni*
>%%LINK%%[[#^xyls3stuyzk|show annotation]]
>%%COMMENT%%
>
>%%TAGS%%
>
^xyls3stuyzk


>%%
>```annotation-json
>{"text":"are parts of _APL thinking_ :\n\n - one liners\n - array (parallel) processing\n    - avoid branching, iteration and recursion\n    - combine cases\n    - work with large chunks\n    - do data-driven computing\n - notation (syntax and symbols themselves)\n - concise APL expressions\n - rich and powerful primitives\n - modularizing code (thanks to direct definitions)\n - ability to generalize\n - identities and proofs in formal reasoning\n\n\n","target":[{"source":"vault:/APL thinking examples.pdf","selector":[{"type":"TextPositionSelector","start":2889,"end":3734},{"type":"TextQuoteSelector","exact":"To some eeople, “APL thinking” suggests one-liners (expressions or defined functions). To others it means array (parallel) processing, thereby avoiding branching, iteration, and recursion: combining cases: working with large chunks: or doing data-driven computing. Some believe it lies in the notation -- syntax and the symbols themselves -- or in concise APL expressions, or in rich and powerful primitives. some relate it to modularizing code (epitomized by direct definition), or a “qlass box” program, or the propensity to generalize. A few attest that it involves use of identities and proofs in formal reasoning. It might also suggest tricky, contorted programming techniques. Further, it might even involve imagery, metaphors, and visualization of mental representations and transformations. Perhaps these are all aspects of APL thinking.","prefix":"iety of interpretations extant.","suffix":"We  have also recognized a numb"}]}],"created":"2022-06-04T12:39:42.674Z","updated":"2022-06-04T12:39:42.674Z","document":{"title":"APL thinking examples.pdf","link":[{"href":"urn:x-pdf:36781331487d52f3605f75c4bdd9e2a8"},{"href":"vault:/APL thinking examples.pdf"}],"documentFingerprint":"36781331487d52f3605f75c4bdd9e2a8"},"uri":"vault:/APL thinking examples.pdf"}
>```
>%%
>*%%PREFIX%%iety of interpretations extant.%%HIGHLIGHT%% ==To some eeople, “APL thinking” suggests one-liners (expressions or defined functions). To others it means array (parallel) processing, thereby avoiding branching, iteration, and recursion: combining cases: working with large chunks: or doing data-driven computing. Some believe it lies in the notation -- syntax and the symbols themselves -- or in concise APL expressions, or in rich and powerful primitives. some relate it to modularizing code (epitomized by direct definition), or a “qlass box” program, or the propensity to generalize. A few attest that it involves use of identities and proofs in formal reasoning. It might also suggest tricky, contorted programming techniques. Further, it might even involve imagery, metaphors, and visualization of mental representations and transformations. Perhaps these are all aspects of APL thinking.== %%POSTFIX%%We  have also recognized a numb*
>%%LINK%%[[#^c281zpherf7|show annotation]]
>%%COMMENT%%
>are parts of _APL thinking_ :
>
> - one liners
> - array (parallel) processing
>    - avoid branching, iteration and recursion
>    - combine cases
>    - work with large chunks
>    - do data-driven computing
> - notation (syntax and symbols themselves)
> - concise APL expressions
> - rich and powerful primitives
> - modularizing code (thanks to direct definitions)
> - ability to generalize
> - identities and proofs in formal reasoning
>
>
>
>%%TAGS%%
>
^c281zpherf7


>%%
>```annotation-json
>{"created":"2022-06-04T13:05:22.767Z","text":"The \"case-by-case\" approach here uses branching.\nThis implementation really is splitting the median in two cases : \n - if the list has an odd number of elements : take the middle element\n - if the list has an even number of elements : take the average of the two \"middle ones\"\n\n","updated":"2022-06-04T13:05:22.767Z","document":{"title":"APL thinking examples.pdf","link":[{"href":"urn:x-pdf:36781331487d52f3605f75c4bdd9e2a8"},{"href":"vault:/APL thinking examples.pdf"}],"documentFingerprint":"36781331487d52f3605f75c4bdd9e2a8"},"uri":"vault:/APL thinking examples.pdf","target":[{"source":"vault:/APL thinking examples.pdf","selector":[{"type":"TextPositionSelector","start":5445,"end":5543},{"type":"TextQuoteSelector","exact":"A straightforward, case-by-case approach directly translates the problem statement into APL code: ","prefix":"es for varied ways of thinking. ","suffix":"Q  Z+MEDIAN X;N Cl1 Z+XC  4x1 [2"}]}]}
>```
>%%
>*%%PREFIX%%es for varied ways of thinking.%%HIGHLIGHT%% ==A straightforward, case-by-case approach directly translates the problem statement into APL code:== %%POSTFIX%%Q  Z+MEDIAN X;N Cl1 Z+XC  4x1 [2*
>%%LINK%%[[#^uxm71iht2bj|show annotation]]
>%%COMMENT%%
>The "case-by-case" approach here uses branching.
>This implementation really is splitting the median in two cases : 
> - if the list has an odd number of elements : take the middle element
> - if the list has an even number of elements : take the average of the two "middle ones"
>
>
>%%TAGS%%
>
^uxm71iht2bj
